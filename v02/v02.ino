/*
 * AVR_Complete_Sensor_System.c
 * Controller: ATmega328P (Arduino Uno)
 * Clock: 16 MHz
 * * WIRING REMINDER:
 * - Ultrasonic Trig: Pin 9  (PB1)
 * - Ultrasonic Echo: Pin 10 (PB2)
 * - Tilt Sensor:     Pin 2  (PD2)
 * - HX711 Data:      Pin 3  (PD3)
 * - HX711 Clock:     Pin 4  (PD4)
 * - OLED SDA:        Pin A4 (PC4)
 * - OLED SCL:        Pin A5 (PC5)
 */

#define F_CPU 16000000UL
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <stdio.h>
#include <stdlib.h>

// --- HARDWARE DEFINITIONS ---
#define TRIG_PIN    PB1
#define ECHO_PIN    PB2
#define TILT_PIN    PD2
#define HX711_DT    PD3
#define HX711_SCK   PD4

#define OLED_ADDR   0x78 // I2C Address (0x3C << 1)

// --- VARIABLES ---
long tare_offset = 0;
float calibration_factor = 420.0f; // ADJUST THIS TO CALIBRATE

// --- FONT TABLE (Stored in Flash Memory to save RAM) ---
// Standard 5x7 ASCII Font (Space through 'z')
const uint8_t font[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, // Space
    0x00, 0x00, 0x5F, 0x00, 0x00, // !
    0x00, 0x07, 0x00, 0x07, 0x00, // "
    0x14, 0x7F, 0x14, 0x7F, 0x14, // #
    0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
    0x23, 0x13, 0x08, 0x64, 0x62, // %
    0x36, 0x49, 0x55, 0x22, 0x50, // &
    0x00, 0x05, 0x03, 0x00, 0x00, // '
    0x00, 0x1C, 0x22, 0x41, 0x00, // (
    0x00, 0x41, 0x22, 0x1C, 0x00, // )
    0x14, 0x08, 0x3E, 0x08, 0x14, // *
    0x08, 0x08, 0x3E, 0x08, 0x08, // +
    0x00, 0x50, 0x30, 0x00, 0x00, // ,
    0x08, 0x08, 0x08, 0x08, 0x08, // -
    0x00, 0x60, 0x60, 0x00, 0x00, // .
    0x20, 0x10, 0x08, 0x04, 0x02, // /
    0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
    0x00, 0x42, 0x7F, 0x40, 0x00, // 1
    0x42, 0x61, 0x51, 0x49, 0x46, // 2
    0x21, 0x41, 0x45, 0x4B, 0x31, // 3
    0x18, 0x14, 0x12, 0x7F, 0x10, // 4
    0x27, 0x45, 0x45, 0x45, 0x39, // 5
    0x3C, 0x4A, 0x49, 0x49, 0x30, // 6
    0x01, 0x71, 0x09, 0x05, 0x03, // 7
    0x36, 0x49, 0x49, 0x49, 0x36, // 8
    0x06, 0x49, 0x49, 0x29, 0x1E, // 9
    0x00, 0x36, 0x36, 0x00, 0x00, // :
    0x00, 0x56, 0x36, 0x00, 0x00, // ;
    0x08, 0x14, 0x22, 0x41, 0x00, // <
    0x14, 0x14, 0x14, 0x14, 0x14, // =
    0x00, 0x41, 0x22, 0x14, 0x08, // >
    0x02, 0x01, 0x51, 0x09, 0x06, // ?
    0x32, 0x49, 0x79, 0x41, 0x3E, // @
    0x7E, 0x11, 0x11, 0x11, 0x7E, // A
    0x7F, 0x49, 0x49, 0x49, 0x36, // B
    0x3E, 0x41, 0x41, 0x41, 0x22, // C
    0x7F, 0x41, 0x41, 0x22, 0x1C, // D
    0x7F, 0x49, 0x49, 0x49, 0x41, // E
    0x7F, 0x09, 0x09, 0x09, 0x01, // F
    0x3E, 0x41, 0x49, 0x49, 0x7A, // G
    0x7F, 0x08, 0x08, 0x08, 0x7F, // H
    0x00, 0x41, 0x7F, 0x41, 0x00, // I
    0x20, 0x40, 0x41, 0x3F, 0x01, // J
    0x7F, 0x08, 0x14, 0x22, 0x41, // K
    0x7F, 0x40, 0x40, 0x40, 0x40, // L
    0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
    0x7F, 0x04, 0x08, 0x10, 0x7F, // N
    0x3E, 0x41, 0x41, 0x41, 0x3E, // O
    0x7F, 0x09, 0x09, 0x09, 0x06, // P
    0x3E, 0x41, 0x51, 0x21, 0x5E, // Q
    0x7F, 0x09, 0x19, 0x29, 0x46, // R
    0x46, 0x49, 0x49, 0x49, 0x31, // S
    0x01, 0x01, 0x7F, 0x01, 0x01, // T
    0x3F, 0x40, 0x40, 0x40, 0x3F, // U
    0x1F, 0x20, 0x40, 0x20, 0x1F, // V
    0x3F, 0x40, 0x38, 0x40, 0x3F, // W
    0x63, 0x14, 0x08, 0x14, 0x63, // X
    0x07, 0x08, 0x70, 0x08, 0x07, // Y
    0x61, 0x51, 0x49, 0x45, 0x43, // Z
    0x00, 0x7F, 0x41, 0x41, 0x00, // [
    0x02, 0x04, 0x08, 0x10, 0x20, // \ 
    0x00, 0x41, 0x41, 0x7F, 0x00, // ]
    0x04, 0x02, 0x01, 0x02, 0x04, // ^
    0x40, 0x40, 0x40, 0x40, 0x40, // _
    0x00, 0x01, 0x02, 0x04, 0x00, // `
    0x20, 0x54, 0x54, 0x54, 0x78, // a
    0x7F, 0x48, 0x44, 0x44, 0x38, // b
    0x38, 0x44, 0x44, 0x44, 0x20, // c
    0x38, 0x44, 0x44, 0x48, 0x7F, // d
    0x38, 0x54, 0x54, 0x54, 0x18, // e
    0x08, 0x7E, 0x09, 0x01, 0x02, // f
    0x0C, 0x52, 0x52, 0x52, 0x3E, // g
    0x7F, 0x08, 0x04, 0x04, 0x78, // h
    0x00, 0x44, 0x7D, 0x40, 0x00, // i
    0x20, 0x40, 0x44, 0x3D, 0x00, // j
    0x7F, 0x10, 0x28, 0x44, 0x00, // k
    0x00, 0x41, 0x7F, 0x40, 0x00, // l
    0x7C, 0x04, 0x18, 0x04, 0x78, // m
    0x7C, 0x08, 0x04, 0x04, 0x78, // n
    0x38, 0x44, 0x44, 0x44, 0x38, // o
    0x7C, 0x14, 0x14, 0x14, 0x08, // p
    0x08, 0x14, 0x14, 0x18, 0x7C, // q
    0x7C, 0x08, 0x04, 0x04, 0x08, // r
    0x48, 0x54, 0x54, 0x54, 0x20, // s
    0x04, 0x3F, 0x44, 0x40, 0x20, // t
    0x3C, 0x40, 0x40, 0x20, 0x7C, // u
    0x1C, 0x20, 0x40, 0x20, 0x1C, // v
    0x3C, 0x40, 0x30, 0x40, 0x3C, // w
    0x44, 0x28, 0x10, 0x28, 0x44, // x
    0x0C, 0x50, 0x50, 0x50, 0x3C, // y
    0x44, 0x64, 0x54, 0x4C, 0x44  // z
};

// ==========================================
// 1. I2C (TWI) DRIVER
// ==========================================
void i2c_init() {
    TWSR = 0x00;
    TWBR = 12; // 400kHz SCL
    TWCR = (1<<TWEN);
}

void i2c_start() {
    TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
    while (!(TWCR & (1<<TWINT)));
}

void i2c_stop() {
    TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
}

void i2c_write(uint8_t data) {
    TWDR = data;
    TWCR = (1<<TWINT)|(1<<TWEN);
    while (!(TWCR & (1<<TWINT)));
}

// ==========================================
// 2. OLED DRIVER (SSD1306)
// ==========================================
void oled_cmd(uint8_t cmd) {
    i2c_start(); i2c_write(OLED_ADDR); i2c_write(0x00); i2c_write(cmd); i2c_stop();
}

void oled_data(uint8_t data) {
    i2c_start(); i2c_write(OLED_ADDR); i2c_write(0x40); i2c_write(data); i2c_stop();
}

void oled_init() {
    _delay_ms(100);
    oled_cmd(0xAE); // OFF
    oled_cmd(0x20); oled_cmd(0x00); // Horiz Mode
    oled_cmd(0x8D); oled_cmd(0x14); // Charge Pump
    oled_cmd(0xAF); // ON
    oled_cmd(0xA6); // Normal display
}

void oled_clear() {
    for (uint8_t p = 0; p < 8; p++) {
        oled_cmd(0xB0 + p); oled_cmd(0x00); oled_cmd(0x10);
        for (uint8_t c = 0; c < 128; c++) oled_data(0x00);
    }
}

void oled_set_cursor(uint8_t page, uint8_t col) {
    oled_cmd(0xB0 + page);
    oled_cmd(0x00 | (col & 0x0F));
    oled_cmd(0x10 | ((col >> 4) & 0x0F));
}

void oled_print(char *str) {
    while (*str) {
        // Calculate offset (ASCII ' ' is 32)
        uint16_t idx = (*str - 32) * 5;
        for (uint8_t i = 0; i < 5; i++) {
            oled_data(pgm_read_byte(&font[idx + i]));
        }
        oled_data(0x00); // Spacing
        str++;
    }
}

// ==========================================
// 3. SENSOR LOGIC
// ==========================================

// --- HX711 ---
long hx711_read() {
    unsigned long count = 0;
    while (PIND & (1 << HX711_DT)); // Wait for Ready

    // Pulse 24 times
    for (uint8_t i = 0; i < 24; i++) {
        PORTD |= (1 << HX711_SCK); _delay_us(1);
        count <<= 1;
        PORTD &= ~(1 << HX711_SCK); _delay_us(1);
        if (PIND & (1 << HX711_DT)) count++;
    }
    
    // Pulse 25th time (Gain 128)
    PORTD |= (1 << HX711_SCK); _delay_us(1);
    PORTD &= ~(1 << HX711_SCK); _delay_us(1);

    // Convert 24-bit to 32-bit signed
    if (count & 0x800000) count |= 0xFF000000;
    return (long)count;
}

// --- ULTRASONIC ---
int get_distance() {
    // Send Trigger
    PORTB &= ~(1 << TRIG_PIN); _delay_us(2);
    PORTB |= (1 << TRIG_PIN);  _delay_us(10);
    PORTB &= ~(1 << TRIG_PIN);

    // Wait for Echo High
    long timeout = 0;
    while (!(PINB & (1 << ECHO_PIN))) {
        if (++timeout > 20000) return 0;
    }

    // Measure High Time
    long count = 0;
    while (PINB & (1 << ECHO_PIN)) {
        _delay_us(1);
        if (++count > 25000) break;
    }
    // Speed of sound calculation (Approx 58uS per cm)
    return (int)(count / 58);
}

// ==========================================
// MAIN LOOP
// ==========================================
int main(void) {
    // --- PIN MODES ---
    DDRB |= (1 << TRIG_PIN);  // Trig Output
    DDRB &= ~(1 << ECHO_PIN); // Echo Input
    DDRD &= ~(1 << TILT_PIN); // Tilt Input
    DDRD &= ~(1 << HX711_DT); // HX711 DT Input
    DDRD |= (1 << HX711_SCK); // HX711 SCK Output

    // --- INIT ---
    i2c_init();
    oled_init();
    oled_clear();

    // --- TARE SCALE ---
    oled_set_cursor(2, 20);
    oled_print("Calibrating...");
    tare_offset = hx711_read();
    _delay_ms(1000);
    oled_clear();

    char buffer[20];

    while (1) {
        // 1. GET DATA
        int dist = get_distance();
        uint8_t tilt = (PIND & (1 << TILT_PIN));
        
        long raw = hx711_read();
        float weight = (float)(raw - tare_offset) / calibration_factor;

        // 2. DISPLAY - TOP (Distance)
        oled_set_cursor(0, 0);
        oled_print("Dist: ");
        itoa(dist, buffer, 10);
        oled_print(buffer);
        oled_print(" cm   "); // Extra spaces to wipe old numbers

        // 3. DISPLAY - MIDDLE (Tilt)
        oled_set_cursor(2, 0);
        oled_print("Tilt: ");
        if (tilt) oled_print("TILTED! ");
        else      oled_print("Stable  ");

        // 4. DISPLAY - BOTTOM (Weight)
        oled_set_cursor(5, 0);
        oled_print("Weight:");
        oled_set_cursor(6, 0);
        
        // Manual float to string (since dtostrf might be missing)
        int w_int = (int)weight;
        int w_dec = abs((int)((weight - w_int) * 10)); // 1 decimal place
        sprintf(buffer, "%d.%d g    ", w_int, w_dec);
        oled_print(buffer);

        _delay_ms(250);
    }
}